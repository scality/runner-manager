"""
This type stub file was generated by pyright.
"""

logger = ...
class Scheduler:
    redis_scheduler_namespace_prefix = ...
    scheduler_key = ...
    scheduler_lock_key = ...
    scheduled_jobs_key = ...
    queue_class = ...
    job_class = ...
    def __init__(self, queue_name=..., queue=..., interval=..., connection=..., job_class=..., queue_class=..., name=...) -> None:
        ...
    
    @property
    def key(self): # -> str:
        """Returns the schedulers Redis hash key."""
        ...
    
    @property
    def pid(self): # -> int:
        """The current process ID."""
        ...
    
    def register_birth(self): # -> None:
        ...
    
    def register_death(self): # -> None:
        """Registers its own death."""
        ...
    
    def acquire_lock(self): # -> bool | None:
        """
        Acquire lock before scheduling jobs to prevent another scheduler
        from scheduling jobs at the same time.

        This function returns True if a lock is acquired. False otherwise.
        """
        ...
    
    def remove_lock(self): # -> None:
        """
        Remove acquired lock.
        """
        ...
    
    def enqueue_at(self, scheduled_time, func, *args, **kwargs): # -> Job | Any:
        """
        Pushes a job to the scheduler queue. The scheduled queue is a Redis sorted
        set ordered by timestamp - which in this case is job's scheduled execution time.

        All args and kwargs are passed onto the job, except for the following kwarg
        keys (which affect the job creation itself):
        - timeout
        - job_id
        - job_ttl
        - job_result_ttl
        - job_description
        - depends_on
        - meta
        - queue_name
        - on_success
        - on_failure
        - at_front

        Usage:

        from datetime import datetime
        from redis import Redis
        from rq.scheduler import Scheduler

        from foo import func

        redis = Redis()
        scheduler = Scheduler(queue_name='default', connection=redis)
        scheduler.enqueue_at(datetime(2020, 1, 1), func, 'argument', keyword='argument')
        """
        ...
    
    def enqueue_in(self, time_delta, func, *args, **kwargs): # -> Job | Any:
        """
        Similar to ``enqueue_at``, but accepts a timedelta instead of datetime object.
        The job's scheduled execution time will be calculated by adding the timedelta
        to datetime.utcnow().
        """
        ...
    
    def schedule(self, scheduled_time, func, args=..., kwargs=..., interval=..., repeat=..., result_ttl=..., ttl=..., timeout=..., id=..., description=..., queue_name=..., meta=..., depends_on=..., on_success=..., on_failure=..., at_front=...): # -> Job | Any:
        """
        Schedule a job to be periodically executed, at a certain interval.
        """
        ...
    
    def cron(self, cron_string, func, args=..., kwargs=..., repeat=..., queue_name=..., result_ttl=..., ttl=..., id=..., timeout=..., description=..., meta=..., use_local_timezone=..., depends_on=..., on_success=..., on_failure=..., at_front: bool = ...): # -> Job | Any:
        """
        Schedule a cronjob
        """
        ...
    
    def cancel(self, job): # -> None:
        """
        Pulls a job from the scheduler queue. This function accepts either a
        job_id or a job instance.
        """
        ...
    
    def __contains__(self, item): # -> bool:
        """
        Returns a boolean indicating whether the given job instance or job id
        is scheduled for execution.
        """
        ...
    
    def change_execution_time(self, job, date_time): # -> None:
        """
        Change a job's execution time.
        """
        ...
    
    def count(self, until=...): # -> int:
        """
        Returns the total number of jobs that are scheduled for all queues.
        This function accepts datetime, timedelta instances as well as
        integers representing epoch values.
        """
        ...
    
    def get_jobs(self, until=..., with_times=..., offset=..., length=...): # -> Generator[tuple[Job | Any | Unknown, Unknown | None] | Job | Any | Unknown, Any, None]:
        """
        Returns a iterator of job instances that will be queued until the given
        time. If no 'until' argument is given all jobs are returned.

        If with_times is True, a list of tuples consisting of the job instance
        and it's scheduled execution time is returned.

        If offset and length are specified, a slice of the list starting at the
        specified zero-based offset of the specified length will be returned.

        If either of offset or length is specified, then both must be, or
        an exception will be raised.
        """
        ...
    
    def get_jobs_to_queue(self, with_times=...): # -> Generator[tuple[Job | Any | Unknown, Unknown | None] | Job | Any | Unknown, Any, None]:
        """
        Returns a list of job instances that should be queued
        (score lower than current timestamp).
        If with_times is True a list of tuples consisting of the job instance and
        it's scheduled execution time is returned.
        """
        ...
    
    def get_queue_for_job(self, job): # -> Any | Queue:
        """
        Returns a queue to put job into.
        """
        ...
    
    def enqueue_job(self, job): # -> None:
        """
        Move a scheduled job to a queue. In addition, it also does puts the job
        back into the scheduler if needed.
        """
        ...
    
    def enqueue_jobs(self): # -> Generator[tuple[Job | Any | Unknown, Unknown | None] | Job | Any | Unknown, Any, None]:
        """
        Move scheduled jobs into queues.
        """
        ...
    
    def heartbeat(self): # -> None:
        """Refreshes schedulers key, typically by extending the
        expiration time of the scheduler, effectively making this a "heartbeat"
        to not expire the scheduler until the timeout passes.
        """
        ...
    
    def run(self, burst=...): # -> None:
        """
        Periodically check whether there's any job that should be put in the queue (score
        lower than current time).
        """
        ...
    


