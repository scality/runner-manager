"""
This type stub file was generated by pyright.
"""

import json
from vmware.vapi.protocol.common.lib import RequestProcessor

"""
SSO Security Helper
"""
__author__ = ...
__copyright__ = ...
key_regex = ...
SAML_SCHEME_ID = ...
SAML_BEARER_SCHEME_ID = ...
PRIVATE_KEY = ...
SAML_TOKEN = ...
SIGNATURE_ALGORITHM = ...
DEFAULT_ALGORITHM_TYPE = ...
TIMESTAMP = ...
EXPIRES = ...
CREATED = ...
REQUEST_VALIDITY = ...
SIGNATURE = ...
DIGEST = ...
AUTHENTICATED = ...
STS_URL_PROP = ...
CERTIFICATE_PROP = ...
PRIVATE_KEY_PROP = ...
CERT_NS = ...
SECTION = ...
algorithm_map = ...

def create_saml_bearer_security_context(token):  # -> SecurityContext:
    """
    Create a security context for SAML bearer token based
    authentication scheme

    :type  token: :class:`str`
    :param token: SAML Token
    """
    ...

def create_saml_security_context(token, private_key):  # -> SecurityContext:
    """
    Create a security context for SAML token based
    authentication scheme

    :type  token: :class:`str`
    :param token: SAML Token
    :type  private_key: :class:`str`
    :param private_key: Absolute file path of the private key of the user
    :rtype: :class:`vmware.vapi.core.SecurityContext`
    :return: Newly created security context
    """
    ...

class JSONCanonicalEncoder(json.JSONEncoder):
    """
    Custom JSON Encoder class to canonicalize dictionary
    and list objects
    """

    def encode(self, o):  # -> str | LiteralString:
        """
        Encode a given python object

        :type  o: :class:`object`
        :param o: Python object
        :rtype: :class:`str`
        :return: JSON string in canonicalized form
        """
        ...

class JSONCanonicalizer:
    """
    This class is responsible for transforming JSON messages into their
    canonical representation.

    The canonical form is defined by the following rules:
        1. Non-significant(1) whitespace characters MUST NOT be used
        2. Non-significant(1) line endings MUST NOT be used
        3. Entries (set of name/value pairs) in JSON objects MUST be sorted
           lexicographically(2) by their names based on UCS codepoint values
        4. Arrays MUST preserve their initial ordering

    Link to the IEFT proposal:
    https://datatracker.ietf.org/doc/draft-staykov-hu-json-canonical-form/
    """

    @staticmethod
    def canonicalize(input_message):  # -> str | LiteralString:
        """
        Canonicalize the input message

        :type  input_message: :class:`str`
        :param input_message: Input message
        :rtype: :class:`str`
        :return: Canonicalized message
        """
        ...

    @staticmethod
    def canonicalize_py_obj(py_obj):  # -> str | LiteralString:
        """
        Canonicalize the input python object

        :type  input_message: :class:`object`
        :param input_message: Input python object
        :rtype: :class:`str`
        :return: Canonicalized message
        """
        ...

class JSONSSOSigner(RequestProcessor):
    """
    This class is used for signing JSON request messages
    """

    def process(self, input_message):  # -> binary_type | str | None:
        """
        Sign the input JSON request message.

        The message is signed using user's private key. The digest and saml
        token is then added to the security context block of the execution
        context. A timestamp is also added to guard against replay attacks

        Sample input security context:
        {
            'schemeId': 'SAML_TOKEN',
            'privateKey': <PRIVATE_KEY>,
            'samlToken': <SAML_TOKEN>,
            'signatureAlgorithm': <ALGORITHM>,
        }

        Security context block before signing:
        {
            'schemeId': 'SAML_TOKEN',
            'signatureAlgorithm': <ALGORITHM>,
            'timestamp': {
                'created': '2012-10-26T12:24:18.941Z',
                'expires': '2012-10-26T12:44:18.941Z',
            }
        }

        Security context block after signing:
        {
            'schemeId': 'SAML_TOKEN',
            'signatureAlgorithm': <ALGORITHM>,
            'signature': {
                'samlToken': <SAML_TOKEN>,
                'value': <DIGEST>
            }
            'timestamp': {
                'created': '2012-10-26T12:24:18.941Z',
                'expires': '2012-10-26T12:44:18.941Z',
            }
        }
        """
        ...

class JSONSSOVerifier(RequestProcessor):
    """
    This class is used to verify the authenticity of the request
    message by verifying the digest present in the security context
    block.
    """

    def process(self, input_message):  # -> binary_type | str | None:
        """
        Verify the input JSON message.

        For verification, we need 4 things:

        1. algorithm: extracted from security context
        2. certificate: public key of the principal embedded in the
        SAML token is used
        3. digest: value field from signature block
        4. canonical msg: signature block is removed from the request
        and the remaining part is canonicalized

        Sample input security context:
        {
            'schemeId': 'SAML_TOKEN',
            'signatureAlgorithm': <ALGORITHM>,
            'signature': {
                'samlToken': <SAML_TOKEN>,
                'value': <DIGEST>
            }
            'timestamp': {
                'created': '2012-10-26T12:24:18.941Z',
                'expires': '2012-10-26T12:44:18.941Z',
            }
        }

        :type  input_message: :class:`str`
        :param input_message: Input JSON request message
        :rtype: :class:`str`
        :return: JSON request message after signature verification
        """
        ...

def parse_xml(xml): ...
